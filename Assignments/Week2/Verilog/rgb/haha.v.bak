module haha (clk, x, i, n, out);
input [31:0] x;
input [6:0] i;
output [31:0] out;

wire [2:0] state
wire resetD, resetM;
wire donee, w;
wire [4:0] i
assign i = 4'd10;
state_machine sm_inst (clk, so_chia, w1, w2, donee, state, resetD, resetM1, resetM2);

assign in_i = (state == 3'b1) ? (i - 1'b1) : i;
always @ (posedge clk) begin
   i = in_i;
	end
//div
reg [31:0] so_chia;
wire [31:0] in_sochia;
wire donee;
wire [31:0] temp1;
chia  chia_hiohi(clk, 32'b01000001010101100000000000000000, so_chia, temp1, donee, resetD);
always @ (state) begin
 if (state == 3'b1)
   so_chia <= i - 1'b1;
	else
	so_chia = so_chia;
	end
//mul1
wire [31:0] temp2, muul;

mulFP khkhk (clk, sum, temp1 , temp2, muul, w1, resetM1);
//mul2
wire [31:0] muul2
mulFP khkhkdf (clk, x, temp2 , temp3, muul2, w2, resetM2);
input [31:0] x;
//add
wire [31:0] sumAll;
wire [31:0] temp4;
part3_addition p3a (32'b01000001010101100000000000000000, temp3, sumAll);
assign sum = (state == 3'd5) ? (sumAll + 1'b1) : sum;
assign out = (state == 3'd7) ? sum : 31'b0;

 
